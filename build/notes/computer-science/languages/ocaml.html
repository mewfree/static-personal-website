<!doctype html><html lang="en"><head><title>OCaml - Damien Gonot</title><link rel="stylesheet" href="/main.css"><link rel="stylesheet" href="/katex.min.css"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="Homepage  Notes  Computer Science  Programming Languages  OCaml

Garbage collection static typechecking with type inference
immutable programming pattern matching

Compilers

   ocamlc bytecode compiler
   ocamlopt native code compiler

Opam

Opam is OCamls package manager

eval opam env in new s..."><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></head><body class="bg-white dark:bg-black"><header class="bg-indigo-600 dark:bg-black text-center text-white p-8"><div class="text-4xl font-bold mb-4">Damien Gonot</div><div class="text-xl flex space-x-8 justify-center"><a href="/" class="hover:underline">Home</a> <a href="/blog" class="hover:underline">Blog</a> <a href="/notes" class="hover:underline">Notes</a> <a href="/about" class="hover:underline">About</a> <button id="theme" class="text-2xl hover:cursor-pointer hover:dark" onclick="toggleTheme()">üåù</button></div><script src="/custom.js"></script><script src="/highlight.js"></script><script defer="defer" src="/katex.min.js"></script><script defer="defer" src="/katex-auto-render.min.js"></script></header><div class="prose prose-indigo dark:prose-invert dark:prose-a:text-indigo-400 max-w-3xl mx-auto p-8"><h1>OCaml</h1><p><a href="../../../homepage">Homepage</a> / <a href="../../../notes">Notes</a> / <a href="../../computer-science">Computer Science</a> / <a href="../languages">Programming Languages</a> / OCaml</p><p>Garbage collection, static type-checking (with type inference), immutable programming, pattern matching.</p><h2 id="compilers">Compilers</h2><ul><li><code class="verbatim">ocamlc</code> bytecode compiler</li><li><code class="verbatim">ocamlopt</code> native code compiler</li></ul><h2 id="opam">Opam</h2><p>Opam is OCaml's package manager.</p><p><code class="verbatim">eval $(opam env)</code> in new shells to activate Opam.</p><ul><li><code class="verbatim">opam init</code> to initialize <code class="verbatim">~/.opam</code></li><li><code class="verbatim">opam search {query}</code> to search for package <code class="verbatim">{query}</code>.</li><li><code class="verbatim">opam show {package}</code> to display information about <code class="verbatim">{package}</code>.</li><li><code class="verbatim">opam install x</code> to install <code class="verbatim">x</code> package.</li><li><code class="verbatim">opam update</code> to update package list.</li><li><code class="verbatim">opam upgrade</code> to upgrade installed packages to their latest version.</li></ul><h2 id="dune">Dune</h2><p>Dune is OCaml's build system.</p><ul><li><code class="verbatim">dune init proj helloworld</code> to init <code class="verbatim">helloworld</code> project.</li><li><code class="verbatim">dune build</code> to build.</li><li><code class="verbatim">dune exec helloworld</code> to build &amp; run.</li></ul><h2 id="repl">REPL</h2><p>Can just type <code class="verbatim">ocaml</code> to access a REPL. But an easier-to-use version is <code class="verbatim">utop</code>.</p><h3 id="utop">utop</h3><p>Basic setup in <code class="verbatim">~/.ocamlinit</code> to load packages every time <code class="verbatim">utop</code> is started:</p><div class="sourceCode" id="cb1" data-results="none" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">#use &quot;topfind&quot;;;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ot">#thread;;</span></span></code></pre></div><h2 id="comments">Comments</h2><div class="sourceCode" id="cb2" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* this is a comment *)</span></span></code></pre></div><h2 id="types">Types</h2><p>The basic types in OCaml are:</p><table><thead><tr class="header"><th>OCaml type</th><th>Range</th></tr></thead><tbody><tr class="odd"><td>'a</td><td>Any type</td></tr><tr class="even"><td>int</td><td>63-bit signed int on 64-bit processors, or 31-bit signed int on 32-bit processors</td></tr><tr class="odd"><td>float</td><td>IEEE double-precision floating point, equivalent to C's double</td></tr><tr class="even"><td>bool</td><td>A boolean, written either 'true' or 'false'</td></tr><tr class="odd"><td>char</td><td>An 8-bit character</td></tr><tr class="even"><td>string</td><td>A string (sequence of 8 bit chars)</td></tr></tbody></table><h3 id="custom-types">Custom Types</h3><div class="sourceCode" id="cb3" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> colour = Red | Green | Blue</span></code></pre></div><pre class="example"><code>type colour = Red | Green | Blue
</code></pre><div class="sourceCode" id="cb5" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> l = [Red; Green; Green]</span></code></pre></div><pre class="example"><code>val l : colour list = [Red; Green; Green]
</code></pre><div class="sourceCode" id="cb7" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> l = [Red; Green; Yellow]</span></code></pre></div><pre class="example"><code>Line 1, characters 21-27:
1 | let l = [Red; Green; Yellow];;
                         ^^^^^^
Error: This variant expression is expected to have type colour
       There is no constructor Yellow within type colour
</code></pre><h3 id="pattern-matching-on-types">Pattern Matching on Types</h3><div class="sourceCode" id="cb9" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> fruit = Banana | Strawberry | Apple;;</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> get_colour = <span class="kw">function</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>| Banana -&gt; <span class="st">&quot;yellow&quot;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>| Strawberry -&gt; <span class="st">&quot;red&quot;</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>| Apple -&gt; <span class="st">&quot;green&quot;</span>;;</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>get_colour Apple;;</span></code></pre></div><pre class="example"><code>green
</code></pre><h2 id="calculations">Calculations</h2><div class="sourceCode" id="cb11" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> + <span class="dv">1</span></span></code></pre></div><pre class="example"><code>2
</code></pre><p>For floats, <code class="verbatim">+.</code> have to be used, as well as <code class="verbatim">x.</code> for the number to be added</p><div class="sourceCode" id="cb13" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fl">1.5</span> +. <span class="dv">1</span>.</span></code></pre></div><pre class="example"><code>2.5
</code></pre><p>Underscores (<code class="verbatim">_</code>) can be used to help read large numbers</p><div class="sourceCode" id="cb15" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="dv">2_000_000</span> / <span class="dv">20_000</span></span></code></pre></div><pre class="example"><code>100
</code></pre><p>Notice the difference between <code class="verbatim">1 / 3</code> and <code class="verbatim">1. /. 3.</code>:</p><div class="sourceCode" id="cb17" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> / <span class="dv">3</span></span></code></pre></div><pre class="example"><code>0
</code></pre><div class="sourceCode" id="cb19" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span>. /. <span class="dv">3</span>.</span></code></pre></div><pre class="example"><code>0.33333333333333331
</code></pre><h2 id="defining-variables">Defining Variables</h2><p>Variable names must start with a lowercase letter or an underscore.</p><div class="sourceCode" id="cb21" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">3</span> + <span class="dv">4</span>;;</span></code></pre></div><pre class="example"><code>7
</code></pre><div class="sourceCode" id="cb23" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> y = x + x;;</span></code></pre></div><pre class="example"><code>14
</code></pre><h3 id="de-structuring-let-bindings">De-structuring let bindings</h3><p>Can be used to define multiple variables at the same time:</p><div class="sourceCode" id="cb25" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x, y = <span class="dv">8</span>, <span class="dv">9</span>;;</span></code></pre></div><pre class="example"><code>val x : int = 8
val y : int = 9
</code></pre><h2 id="chars">Chars</h2><p>Chars use single-quotes:</p><div class="sourceCode" id="cb27" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ch">&#39;d&#39;</span>;;</span></code></pre></div><pre class="example"><code>- : char = d
</code></pre><h2 id="strings">Strings</h2><p><a href="https://ocaml.org/api/String.html">https://ocaml.org/api/String.html</a></p><p>Strings use double-quotes:</p><div class="sourceCode" id="cb29" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> name = <span class="st">&quot;Damien&quot;</span>;;</span></code></pre></div><pre class="example"><code>val name : string = &quot;Damien&quot;
</code></pre><h3 id="list-of-chars">List of Chars</h3><p>Strings are essentially lists of characters</p><div class="sourceCode" id="cb31" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>name.[<span class="dv">0</span>];;</span></code></pre></div><pre class="example"><code>- : char = &#39;D&#39;
</code></pre><div class="sourceCode" id="cb33" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>name.[<span class="dv">1</span>];;</span></code></pre></div><pre class="example"><code>- : char = &#39;a&#39;
</code></pre><h3 id="length">Length</h3><div class="sourceCode" id="cb35" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="dt">String</span>.length name;;</span></code></pre></div><pre class="example"><code>- : int = 6
</code></pre><h3 id="concatenation">Concatenation</h3><p><code class="verbatim">^</code> is used to concatenate strings.</p><div class="sourceCode" id="cb37" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;Hello, &quot;</span> ^ name;;</span></code></pre></div><pre class="example"><code>&quot;Hello, Damien&quot;
</code></pre><h3 id="starts-with">Starts With</h3><div class="sourceCode" id="cb39" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="dt">String</span>.starts_with ~prefix:<span class="st">&quot;Dam&quot;</span> name;;</span></code></pre></div><pre class="example"><code>- : bool = true
</code></pre><div class="sourceCode" id="cb41" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="dt">String</span>.starts_with ~prefix:<span class="st">&quot;ien&quot;</span> name;;</span></code></pre></div><pre class="example"><code>- : bool = false
</code></pre><h3 id="ends-with">Ends With</h3><div class="sourceCode" id="cb43" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="dt">String</span>.ends_with ~suffix:<span class="st">&quot;ien&quot;</span> name;;</span></code></pre></div><pre class="example"><code>- : bool = true
</code></pre><div class="sourceCode" id="cb45" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="dt">String</span>.ends_with ~suffix:<span class="st">&quot;Dam&quot;</span> name;;</span></code></pre></div><pre class="example"><code>- : bool = false
</code></pre><h2 id="functions">Functions</h2><div class="sourceCode" id="cb47" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> plus x y = x + y;;</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>plus <span class="dv">2</span> <span class="dv">3</span>;;</span></code></pre></div><pre class="example"><code>5
</code></pre><p>Example of partial application:</p><div class="sourceCode" id="cb49" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> plus_two = plus <span class="dv">2</span>;;</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>plus_two <span class="dv">3</span>;;</span></code></pre></div><pre class="example"><code>5
</code></pre><div class="sourceCode" id="cb51" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> square x = x * x;;</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>square <span class="dv">3</span></span></code></pre></div><pre class="example"><code>9
</code></pre><div class="sourceCode" id="cb53" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ratio x y = Float.of_int x /. Float.of_int y;;</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>ratio <span class="dv">1</span> <span class="dv">3</span>;;</span></code></pre></div><pre class="example"><code>0.33333333333333331
</code></pre><h3 id="anonymous-functions">Anonymous Functions</h3><p>using <code class="verbatim">stdlib</code></p><div class="sourceCode" id="cb55" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.map (<span class="kw">fun</span> x -&gt; x * <span class="dv">2</span>) [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>];;</span></code></pre></div><pre class="example"><code>- : int list = [2; 4; 6]
</code></pre><p>using <code class="verbatim">Base</code> from Jane Street</p><div class="sourceCode" id="cb57" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.map [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>] ~f:(<span class="kw">fun</span> x -&gt; x*<span class="dv">2</span>);;</span></code></pre></div><pre class="example"><code>- : int list = [2; 4; 6]
</code></pre><h2 id="data-structures">Data Structures</h2><h3 id="tuples">Tuples</h3><p>Ordered collection of values that can each be of a different type.</p><div class="sourceCode" id="cb59" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> tuple_a = (<span class="dv">9</span>, <span class="st">&quot;nine&quot;</span>);;</span></code></pre></div><pre class="example"><code>val tuple_a : int * string = (9, &quot;nine&quot;)
</code></pre><div class="sourceCode" id="cb61" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> tuple_b = (<span class="dv">9</span>, <span class="st">&quot;nine&quot;</span>, <span class="dv">9</span>.);;</span></code></pre></div><pre class="example"><code>val tuple_b : int * string * float = (9, &quot;nine&quot;, 9.)
</code></pre><p>Values can be extracted from the tuple by using pattern matching:</p><div class="sourceCode" id="cb63" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (x,y) = tuple_a;;</span></code></pre></div><pre class="example"><code>val x : int = 9
val y : string = &quot;nine&quot;
</code></pre><div class="sourceCode" id="cb65" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>x + <span class="dt">String</span>.length y;;</span></code></pre></div><pre class="example"><code>- : Base.Int.t = 13
</code></pre><h3 id="lists">Lists</h3><p><a href="https://ocaml.org/api/List.html">https://ocaml.org/api/List.html</a></p><p>Any number of (ordered) items of the same type.</p><div class="sourceCode" id="cb67" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> countries = [<span class="st">&quot;United States&quot;</span>; <span class="st">&quot;France&quot;</span>; <span class="st">&quot;Canada&quot;</span>]</span></code></pre></div><pre class="example"><code>val countries : string list = [&quot;United States&quot;; &quot;France&quot;; &quot;Canada&quot;]
</code></pre><p>Mixing types is not possible in lists:</p><div class="sourceCode" id="cb69" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> numbers = [<span class="dv">1</span>;<span class="st">&quot;two&quot;</span>;<span class="dv">3</span>]</span></code></pre></div><pre class="example"><code>Line 1, characters 17-22:
1 | let numbers = [1;&quot;two&quot;;3];;
                     ^^^^^
Error: This expression has type string but an expression was expected of type
         int
</code></pre><h4 id="semicolons-vs-commas">Semicolons vs Commas</h4><p>Because commas are reserved to separate elements of tuples, using them in Lists returns a tuple inside a list:</p><div class="sourceCode" id="cb71" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>[<span class="st">&quot;OCaml&quot;</span>, <span class="st">&quot;Python&quot;</span>, <span class="st">&quot;Ruby&quot;</span>];;</span></code></pre></div><pre class="example"><code>- : (string * string * string) list = [(&quot;OCaml&quot;, &quot;Python&quot;, &quot;Ruby&quot;)]
</code></pre><p>Even without parentheses, commas create a tuple:</p><div class="sourceCode" id="cb73" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>;;</span></code></pre></div><pre class="example"><code>- : int * int * int = (1, 2, 3)
</code></pre><h4 id="length-1">Length</h4><p>Getting the length of a list:</p><div class="sourceCode" id="cb75" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.length countries;;</span></code></pre></div><pre class="example"><code>3
</code></pre><h4 id="nth">Nth</h4><div class="sourceCode" id="cb77" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.nth [<span class="st">&quot;a&quot;</span>; <span class="st">&quot;b&quot;</span>; <span class="st">&quot;c&quot;</span>] <span class="dv">2</span>;;</span></code></pre></div><pre class="example"><code>c
</code></pre><h4 id="mem">Mem</h4><p>Short for "member of" list</p><div class="sourceCode" id="cb79" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.mem <span class="st">&quot;France&quot;</span> countries;;</span></code></pre></div><pre class="example"><code>- : bool = true
</code></pre><div class="sourceCode" id="cb81" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.mem <span class="st">&quot;China&quot;</span> countries;;</span></code></pre></div><pre class="example"><code>- : bool = false
</code></pre><h4 id="prepending">Prepending</h4><p>Prepending to a list:</p><div class="sourceCode" id="cb83" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;Germany&quot;</span> :: <span class="st">&quot;Spain&quot;</span> :: countries;;</span></code></pre></div><pre class="example"><code>- : string list = [&quot;Germany&quot;; &quot;Spain&quot;; &quot;United States&quot;; &quot;France&quot;; &quot;Canada&quot;]
</code></pre><p>Note the initial list is unchanged:</p><div class="sourceCode" id="cb85" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a>countries;;</span></code></pre></div><pre class="example"><code>- : string list = [&quot;United States&quot;; &quot;France&quot;; &quot;Canada&quot;]
</code></pre><h4 id="concatenate-lists">Concatenate Lists</h4><div class="sourceCode" id="cb87" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>] @ [<span class="dv">4</span>; <span class="dv">5</span>; <span class="dv">6</span>];;</span></code></pre></div><pre class="example"><code>- : int Base.List.t = [1; 2; 3; 4; 5; 6]
</code></pre><h4 id="pattern-matching-on-lists">Pattern Matching on Lists</h4><p>Compiler warns us that the code below is incomplete, because it doesn't support the case where countries is an empty list.</p><div class="sourceCode" id="cb89" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> favourite :: the_rest = countries;;</span></code></pre></div><pre class="example"><code>Line 1, characters 4-25:
1 | let favourite :: the_rest = countries;;;;
        ^^^^^^^^^^^^^^^^^^^^^
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
[]
val favourite : string = &quot;United States&quot;
val the_rest : string list = [&quot;France&quot;; &quot;Canada&quot;]
</code></pre><p>Using <code class="verbatim">match</code> instead:</p><div class="sourceCode" id="cb91" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> my_favourite_country countries =</span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> countries <span class="kw">with</span></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a>  | first :: the_rest -&gt; first</span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; <span class="st">&quot;Canada&quot;</span></span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a>;;</span></code></pre></div><pre class="example"><code>val my_favourite_country : string list -&gt; string = &lt;fun&gt;
</code></pre><div class="sourceCode" id="cb93" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a>my_favourite_country countries;;</span></code></pre></div><pre class="example"><code>United States
</code></pre><div class="sourceCode" id="cb95" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a>my_favourite_country [];;</span></code></pre></div><pre class="example"><code>Canada
</code></pre><h4 id="iter">Iter</h4><div class="sourceCode" id="cb97" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.iter <span class="dt">print_endline</span> [<span class="st">&quot;a&quot;</span>; <span class="st">&quot;b&quot;</span>; <span class="st">&quot;c&quot;</span>];;</span></code></pre></div><pre class="example"><code>a
b
c
- : unit = ()
</code></pre><h4 id="map">Map</h4><p><code class="verbatim">map</code> over list:</p><div class="sourceCode" id="cb99" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.map <span class="dt">String</span>.length countries;;</span></code></pre></div><pre class="example"><code>- : int list = [13; 6; 6]
</code></pre><p>Using <code class="verbatim">StdLabels</code>:</p><div class="sourceCode" id="cb101" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> <span class="dt">StdLabels</span>;;</span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.map ~f:<span class="dt">String</span>.length countries;;</span></code></pre></div><pre class="example"><code>- : int list = [13; 6; 6]
</code></pre><h4 id="map2">Map2</h4><p>Called <code class="verbatim">zip</code> in most other languages?</p><div class="sourceCode" id="cb103" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.map2 ( + ) [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>] [<span class="dv">4</span>; <span class="dv">5</span>; <span class="dv">6</span>];;</span></code></pre></div><pre class="example"><code>- : int list = [5; 7; 9]
</code></pre><h4 id="find">Find</h4><p>Returns first element given predicate:</p><div class="sourceCode" id="cb105" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.find (<span class="kw">fun</span> x -&gt; x &gt; <span class="dv">2</span>) [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>; <span class="dv">5</span>];;</span></code></pre></div><pre class="example"><code>3
</code></pre><h4 id="filter">Filter</h4><p>Returns <strong>all</strong> element given predicate:</p><div class="sourceCode" id="cb107" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.filter (<span class="kw">fun</span> x -&gt; x &gt; <span class="dv">2</span>) [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>; <span class="dv">5</span>];;</span></code></pre></div><pre class="example"><code>- : int list = [3; 4; 5]
</code></pre><h4 id="sort">Sort</h4><p>Comparison feature <code class="verbatim">compare</code> can be used:</p><div class="sourceCode" id="cb109" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.sort <span class="dt">compare</span> [<span class="dv">3</span>; <span class="dv">4</span>; <span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">4</span>; <span class="dv">5</span>];;</span></code></pre></div><pre class="example"><code>- : int list = [1; 2; 3; 4; 4; 5]
</code></pre><p><code class="verbatim">Fun.flip</code> flips the arguments of a binary function, meaning x &lt; y will become y &lt; x:</p><div class="sourceCode" id="cb111" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.sort (Fun.flip <span class="dt">compare</span>) [<span class="dv">3</span>; <span class="dv">4</span>; <span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">4</span>; <span class="dv">5</span>];;</span></code></pre></div><pre class="example"><code>- : int list = [5; 4; 4; 3; 2; 1]
</code></pre><h4 id="folds">Folds</h4><h5 id="fold-left">Fold left</h5><div class="sourceCode" id="cb113" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.fold_left ( + ) <span class="dv">0</span> [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>];;</span></code></pre></div><pre class="example"><code>6
</code></pre><div class="sourceCode" id="cb115" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.fold_left ( - ) <span class="dv">0</span> [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>];;</span></code></pre></div><pre class="example"><code>-6
</code></pre><h5 id="fold-right">Fold right</h5><p>Accumulator is placed after the list:</p><div class="sourceCode" id="cb117" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.fold_right ( + ) [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>] <span class="dv">0</span>;;</span></code></pre></div><pre class="example"><code>6
</code></pre><div class="sourceCode" id="cb119" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.fold_right ( - ) [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>] <span class="dv">0</span>;;</span></code></pre></div><pre class="example"><code>2
</code></pre><h4 id="partition">Partition</h4><p>If you also need elements which tested false:</p><div class="sourceCode" id="cb121" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.partition (<span class="kw">fun</span> x -&gt; x &gt; <span class="dv">2</span>) [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>; <span class="dv">5</span>];;</span></code></pre></div><pre class="example"><code>- : int list * int list = ([3; 4; 5], [1; 2])
</code></pre><h4 id="recursive-list-functions">Recursive List Functions</h4><div class="sourceCode" id="cb123" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> sum l =</span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; <span class="dv">0</span></span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a>  | hd :: tl -&gt; hd + sum tl</span>
<span id="cb123-5"><a href="#cb123-5" aria-hidden="true" tabindex="-1"></a>;;</span></code></pre></div><pre class="example"><code>val sum : Base.Int.t list -&gt; Base.Int.t = &lt;fun&gt;
</code></pre><div class="sourceCode" id="cb125" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a>sum [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>];;</span></code></pre></div><pre class="example"><code>6
</code></pre><h4 id="association-lists">Association lists</h4><p>Simplistic dictionary data structure:</p><div class="sourceCode" id="cb127" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> numbers = [(<span class="dv">1</span>, <span class="st">&quot;one&quot;</span>); (<span class="dv">2</span>, <span class="st">&quot;two&quot;</span>); (<span class="dv">3</span>, <span class="st">&quot;three&quot;</span>); (<span class="dv">4</span>, <span class="st">&quot;four&quot;</span>); (<span class="dv">5</span>, <span class="st">&quot;five&quot;</span>)];;</span></code></pre></div><pre class="example"><code>val numbers : (int * string) list =
  [(1, &quot;one&quot;); (2, &quot;two&quot;); (3, &quot;three&quot;); (4, &quot;four&quot;); (5, &quot;five&quot;)]
</code></pre><h5 id="get-value-from-key">Get value from key</h5><div class="sourceCode" id="cb129" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.assoc <span class="dv">3</span> numbers;;</span></code></pre></div><pre class="example"><code>- : string = &quot;three&quot;
</code></pre><h5 id="check-that-key-exists">Check that key exists</h5><div class="sourceCode" id="cb131" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.mem_assoc <span class="dv">3</span> numbers;;</span></code></pre></div><pre class="example"><code>- : bool = true
</code></pre><div class="sourceCode" id="cb133" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.mem_assoc <span class="dv">6</span> numbers;;</span></code></pre></div><pre class="example"><code>- : bool = false
</code></pre><h5 id="split-keys-and-values">Split keys and values</h5><div class="sourceCode" id="cb135" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.split numbers;;</span></code></pre></div><pre class="example"><code>- : int list * string list =
([1; 2; 3; 4; 5], [&quot;one&quot;; &quot;two&quot;; &quot;three&quot;; &quot;four&quot;; &quot;five&quot;])
</code></pre><h5 id="combine-keys-and-values-to-create-an-association-list">Combine keys and values to create an association list</h5><div class="sourceCode" id="cb137" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.combine [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>; <span class="dv">5</span>] [<span class="st">&quot;one&quot;</span>; <span class="st">&quot;two&quot;</span>; <span class="st">&quot;three&quot;</span>; <span class="st">&quot;four&quot;</span>; <span class="st">&quot;five&quot;</span>];;</span></code></pre></div><pre class="example"><code>- : (int * string) list =
[(1, &quot;one&quot;); (2, &quot;two&quot;); (3, &quot;three&quot;); (4, &quot;four&quot;); (5, &quot;five&quot;)]
</code></pre><h3 id="records-and-variants">Records and Variants</h3><div class="sourceCode" id="cb139" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> point2d = { x : <span class="dt">float</span>; y : <span class="dt">float</span> }</span></code></pre></div><pre class="example"><code>type point2d = { x : Base.float; y : Base.float; }
</code></pre><div class="sourceCode" id="cb141" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> p = { x = <span class="dv">3</span>.; y = <span class="dv">-4</span>. };;</span></code></pre></div><pre class="example"><code>val p : point2d = {x = 3.; y = -4.}
</code></pre><div class="sourceCode" id="cb143" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> magnitude { x = x_pos; y = y_pos } =</span>
<span id="cb143-2"><a href="#cb143-2" aria-hidden="true" tabindex="-1"></a>  Float.<span class="dt">sqrt</span> (x_pos **. <span class="dv">2</span>. +. y_pos **. <span class="dv">2</span>.)</span>
<span id="cb143-3"><a href="#cb143-3" aria-hidden="true" tabindex="-1"></a>;;</span></code></pre></div><pre class="example"><code>val magnitude : point2d -&gt; Base.Float.t = &lt;fun&gt;
</code></pre><p>Using <em>field punning</em> for a more terse definition:</p><div class="sourceCode" id="cb145" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> magnitude { x; y } = Float.<span class="dt">sqrt</span> (x **. <span class="dv">2</span>. +. y **. <span class="dv">2</span>.);;</span></code></pre></div><pre class="example"><code>val magnitude : point2d -&gt; Base.Float.t = &lt;fun&gt;
</code></pre><p>You can re-use types as components of larger types:</p><div class="sourceCode" id="cb147" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> circle_desc  = { center: point2d; radius: <span class="dt">float</span> }</span></code></pre></div><pre class="example"><code>type circle_desc = { center : point2d; radius : Base.float; }
</code></pre><h3 id="maps">Maps</h3><div class="sourceCode" id="cb149" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> Names = <span class="dt">Map</span>.Make(<span class="dt">String</span>);;</span></code></pre></div><pre class="example"><code>module Names :
  sig
    type key = String.t
    type &#39;a t = &#39;a Map.Make(String).t
    val empty : &#39;a t
    val is_empty : &#39;a t -&gt; bool
    val mem : key -&gt; &#39;a t -&gt; bool
    val add : key -&gt; &#39;a -&gt; &#39;a t -&gt; &#39;a t
    val update : key -&gt; (&#39;a option -&gt; &#39;a option) -&gt; &#39;a t -&gt; &#39;a t
    val singleton : key -&gt; &#39;a -&gt; &#39;a t
    val remove : key -&gt; &#39;a t -&gt; &#39;a t
    val merge :
      (key -&gt; &#39;a option -&gt; &#39;b option -&gt; &#39;c option) -&gt; &#39;a t -&gt; &#39;b t -&gt; &#39;c t
    val union : (key -&gt; &#39;a -&gt; &#39;a -&gt; &#39;a option) -&gt; &#39;a t -&gt; &#39;a t -&gt; &#39;a t
    val compare : (&#39;a -&gt; &#39;a -&gt; int) -&gt; &#39;a t -&gt; &#39;a t -&gt; int
    val equal : (&#39;a -&gt; &#39;a -&gt; bool) -&gt; &#39;a t -&gt; &#39;a t -&gt; bool
    val iter : (key -&gt; &#39;a -&gt; unit) -&gt; &#39;a t -&gt; unit
    val fold : (key -&gt; &#39;a -&gt; &#39;b -&gt; &#39;b) -&gt; &#39;a t -&gt; &#39;b -&gt; &#39;b
    val for_all : (key -&gt; &#39;a -&gt; bool) -&gt; &#39;a t -&gt; bool
    val exists : (key -&gt; &#39;a -&gt; bool) -&gt; &#39;a t -&gt; bool
    val filter : (key -&gt; &#39;a -&gt; bool) -&gt; &#39;a t -&gt; &#39;a t
    val filter_map : (key -&gt; &#39;a -&gt; &#39;b option) -&gt; &#39;a t -&gt; &#39;b t
    val partition : (key -&gt; &#39;a -&gt; bool) -&gt; &#39;a t -&gt; &#39;a t * &#39;a t
    val cardinal : &#39;a t -&gt; int
    val bindings : &#39;a t -&gt; (key * &#39;a) list
    val min_binding : &#39;a t -&gt; key * &#39;a
    val min_binding_opt : &#39;a t -&gt; (key * &#39;a) option
    val max_binding : &#39;a t -&gt; key * &#39;a
    val max_binding_opt : &#39;a t -&gt; (key * &#39;a) option
    val choose : &#39;a t -&gt; key * &#39;a
    val choose_opt : &#39;a t -&gt; (key * &#39;a) option
    val split : key -&gt; &#39;a t -&gt; &#39;a t * &#39;a option * &#39;a t
    val find : key -&gt; &#39;a t -&gt; &#39;a
    val find_opt : key -&gt; &#39;a t -&gt; &#39;a option
    val find_first : (key -&gt; bool) -&gt; &#39;a t -&gt; key * &#39;a
    val find_first_opt : (key -&gt; bool) -&gt; &#39;a t -&gt; (key * &#39;a) option
    val find_last : (key -&gt; bool) -&gt; &#39;a t -&gt; key * &#39;a
    val find_last_opt : (key -&gt; bool) -&gt; &#39;a t -&gt; (key * &#39;a) option
    val map : (&#39;a -&gt; &#39;b) -&gt; &#39;a t -&gt; &#39;b t
    val mapi : (key -&gt; &#39;a -&gt; &#39;b) -&gt; &#39;a t -&gt; &#39;b t
    val to_seq : &#39;a t -&gt; (key * &#39;a) Seq.t
    val to_rev_seq : &#39;a t -&gt; (key * &#39;a) Seq.t
    val to_seq_from : key -&gt; &#39;a t -&gt; (key * &#39;a) Seq.t
    val add_seq : (key * &#39;a) Seq.t -&gt; &#39;a t -&gt; &#39;a t
    val of_seq : (key * &#39;a) Seq.t -&gt; &#39;a t
  end
</code></pre><p>Create an empty <code class="verbatim">Names</code> map <code class="verbatim">n</code>:</p><div class="sourceCode" id="cb151" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> n = Names.empty;;</span></code></pre></div><pre class="example"><code>val n : &#39;a Names.t = &lt;abstr&gt;
</code></pre><p>Add some data, by overwriting previous <code class="verbatim">n</code>:</p><div class="sourceCode" id="cb153" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> n = Names.add <span class="st">&quot;Damien&quot;</span> <span class="st">&quot;Gonot&quot;</span> n;;</span></code></pre></div><pre class="example"><code>val n : string Names.t = &lt;abstr&gt;
</code></pre><p>And more:</p><div class="sourceCode" id="cb155" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> n = Names.add <span class="st">&quot;John&quot;</span> <span class="st">&quot;Doe&quot;</span> n;;</span>
<span id="cb155-2"><a href="#cb155-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> n = Names.add <span class="st">&quot;Hercules&quot;</span> <span class="st">&quot;Poirot&quot;</span> n;;</span></code></pre></div><pre class="example"><code>val n : string Names.t = &lt;abstr&gt;
</code></pre><div class="sourceCode" id="cb157" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> print_name first_name last_name =</span>
<span id="cb157-2"><a href="#cb157-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">print_endline</span>(first_name ^ <span class="st">&quot; &quot;</span> ^ last_name);;</span></code></pre></div><pre class="example"><code>val print_name : string -&gt; string -&gt; unit = &lt;fun&gt;
</code></pre><div class="sourceCode" id="cb159" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a>Names.iter print_name n;;</span></code></pre></div><pre class="example"><code>Damien Gonot
Hercules Poirot
John Doe
- : unit = ()
</code></pre><div class="sourceCode" id="cb161" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a>Names.find <span class="st">&quot;Damien&quot;</span> n;;</span></code></pre></div><pre class="example"><code>- : string = &quot;Gonot&quot;
</code></pre><h3 id="sets">Sets</h3><div class="sourceCode" id="cb163" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> StringSet = <span class="dt">Set</span>.Make(<span class="dt">String</span>);;</span></code></pre></div><pre class="example"><code>module StringSet :
  sig
    type elt = String.t
    type t = Set.Make(String).t
    val empty : t
    val is_empty : t -&gt; bool
    val mem : elt -&gt; t -&gt; bool
    val add : elt -&gt; t -&gt; t
    val singleton : elt -&gt; t
    val remove : elt -&gt; t -&gt; t
    val union : t -&gt; t -&gt; t
    val inter : t -&gt; t -&gt; t
    val disjoint : t -&gt; t -&gt; bool
    val diff : t -&gt; t -&gt; t
    val compare : t -&gt; t -&gt; int
    val equal : t -&gt; t -&gt; bool
    val subset : t -&gt; t -&gt; bool
    val iter : (elt -&gt; unit) -&gt; t -&gt; unit
    val map : (elt -&gt; elt) -&gt; t -&gt; t
    val fold : (elt -&gt; &#39;a -&gt; &#39;a) -&gt; t -&gt; &#39;a -&gt; &#39;a
    val for_all : (elt -&gt; bool) -&gt; t -&gt; bool
    val exists : (elt -&gt; bool) -&gt; t -&gt; bool
    val filter : (elt -&gt; bool) -&gt; t -&gt; t
    val filter_map : (elt -&gt; elt option) -&gt; t -&gt; t
    val partition : (elt -&gt; bool) -&gt; t -&gt; t * t
    val cardinal : t -&gt; int
    val elements : t -&gt; elt list
    val min_elt : t -&gt; elt
    val min_elt_opt : t -&gt; elt option
    val max_elt : t -&gt; elt
    val max_elt_opt : t -&gt; elt option
    val choose : t -&gt; elt
    val choose_opt : t -&gt; elt option
    val split : elt -&gt; t -&gt; t * bool * t
    val find : elt -&gt; t -&gt; elt
    val find_opt : elt -&gt; t -&gt; elt option
    val find_first : (elt -&gt; bool) -&gt; t -&gt; elt
    val find_first_opt : (elt -&gt; bool) -&gt; t -&gt; elt option
    val find_last : (elt -&gt; bool) -&gt; t -&gt; elt
    val find_last_opt : (elt -&gt; bool) -&gt; t -&gt; elt option
    val of_list : elt list -&gt; t
    val to_seq_from : elt -&gt; t -&gt; elt Seq.t
    val to_seq : t -&gt; elt Seq.t
    val to_rev_seq : t -&gt; elt Seq.t
    val add_seq : elt Seq.t -&gt; t -&gt; t
    val of_seq : elt Seq.t -&gt; t
  end
</code></pre><div class="sourceCode" id="cb165" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> s = StringSet.singleton <span class="st">&quot;hello&quot;</span>;;</span></code></pre></div><pre class="example"><code>val s : StringSet.t = &lt;abstr&gt;
</code></pre><div class="sourceCode" id="cb167" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> s = <span class="dt">List</span>.fold_right StringSet.add [<span class="st">&quot;world&quot;</span>; <span class="st">&quot;stranger&quot;</span>] s;;</span></code></pre></div><pre class="example"><code>val s : StringSet.t = &lt;abstr&gt;
</code></pre><div class="sourceCode" id="cb169" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true" tabindex="-1"></a>StringSet.iter (<span class="kw">fun</span> str -&gt; <span class="dt">print_endline</span> str) s;;</span></code></pre></div><pre class="example"><code>hello
stranger
world
- : unit = ()
</code></pre><div class="sourceCode" id="cb171" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true" tabindex="-1"></a>StringSet.mem <span class="st">&quot;stranger&quot;</span> s;</span></code></pre></div><pre class="example"><code>- : bool = true
</code></pre><h3 id="hash-tables">Hash Tables</h3><p><code class="verbatim">1000</code> is the initial size of the hash table. Hash tables can grow further is size has been underestimated.</p><div class="sourceCode" id="cb173" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb173-1"><a href="#cb173-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> my_hash = <span class="dt">Hashtbl</span>.create <span class="dv">1000</span>;;</span></code></pre></div><pre class="example"><code>val my_hash : (&#39;_weak1, &#39;_weak2) Hashtbl.t = &lt;abstr&gt;
</code></pre><p><code class="verbatim">'_weak1</code> is the type for the key and <code class="verbatim">'_weak2</code> the type for the value</p><p>There are no concrete types yet. The underscore indicates that once the key and value types will be chosen, they'll be fixed.</p><p>Hash tables are updated in-place, adding a new member doesn't return a new hash table like maps do.</p><div class="sourceCode" id="cb175" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Hashtbl</span>.add my_hash <span class="st">&quot;h&quot;</span> <span class="st">&quot;hello&quot;</span>;;</span>
<span id="cb175-2"><a href="#cb175-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Hashtbl</span>.add my_hash <span class="st">&quot;h&quot;</span> <span class="st">&quot;harbour&quot;</span>;;</span>
<span id="cb175-3"><a href="#cb175-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Hashtbl</span>.add my_hash <span class="st">&quot;w&quot;</span> <span class="st">&quot;world&quot;</span>;;</span>
<span id="cb175-4"><a href="#cb175-4" aria-hidden="true" tabindex="-1"></a><span class="dt">Hashtbl</span>.add my_hash <span class="st">&quot;w&quot;</span> <span class="st">&quot;win&quot;</span>;;</span>
<span id="cb175-5"><a href="#cb175-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Hashtbl</span>.add my_hash <span class="st">&quot;w&quot;</span> <span class="st">&quot;wonderful&quot;</span>;;</span></code></pre></div><pre class="example"><code>- : unit = ()
</code></pre><p>Types are fixed now:</p><div class="sourceCode" id="cb177" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true" tabindex="-1"></a>my_hash;;</span></code></pre></div><pre class="example"><code>- : (string, string) Hashtbl.t = &lt;abstr&gt;
</code></pre><h4 id="find-1">Find</h4><p><code class="verbatim">Hashtbl.find</code> returns the <strong>last</strong> added element:</p><div class="sourceCode" id="cb179" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb179-1"><a href="#cb179-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Hashtbl</span>.find my_hash <span class="st">&quot;h&quot;</span>;;</span></code></pre></div><pre class="example"><code>- : string = &quot;harbour&quot;
</code></pre><h4 id="find-all">Find all</h4><p>To find <strong>all</strong> elements:</p><div class="sourceCode" id="cb181" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb181-1"><a href="#cb181-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Hashtbl</span>.find_all my_hash <span class="st">&quot;w&quot;</span>;;</span></code></pre></div><pre class="example"><code>- : string list = [&quot;wonderful&quot;; &quot;win&quot;; &quot;world&quot;]
</code></pre><h4 id="replace">Replace</h4><p>Instead of using <code class="verbatim">Hashtbl.add</code>, we can use <code class="verbatim">Hashtbl.replace</code> if we only want one value per key:</p><div class="sourceCode" id="cb183" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb183-1"><a href="#cb183-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Hashtbl</span>.replace my_hash <span class="st">&quot;t&quot;</span> <span class="st">&quot;try&quot;</span>;;</span>
<span id="cb183-2"><a href="#cb183-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Hashtbl</span>.replace my_hash <span class="st">&quot;t&quot;</span> <span class="st">&quot;test&quot;</span>;;</span>
<span id="cb183-3"><a href="#cb183-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Hashtbl</span>.find_all my_hash <span class="st">&quot;t&quot;</span>;;</span></code></pre></div><pre class="example"><code>- : string list = [&quot;test&quot;]
</code></pre><div class="sourceCode" id="cb185" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb185-1"><a href="#cb185-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Hashtbl</span>.remove my_hash <span class="st">&quot;t&quot;</span>;;</span>
<span id="cb185-2"><a href="#cb185-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Hashtbl</span>.find my_hash <span class="st">&quot;t&quot;</span>;;</span></code></pre></div><pre class="example"><code>Exception: Not_found.
</code></pre><h2 id="scope">Scope</h2><div class="sourceCode" id="cb187" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb187-1"><a href="#cb187-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> z = <span class="dv">7</span> <span class="kw">in</span></span>
<span id="cb187-2"><a href="#cb187-2" aria-hidden="true" tabindex="-1"></a>z + z</span>
<span id="cb187-3"><a href="#cb187-3" aria-hidden="true" tabindex="-1"></a>;;</span></code></pre></div><pre class="example"><code>14
</code></pre><p>The scope of the <code class="verbatim">let</code> binding is terminated by the <code class="verbatim">;;</code>, value of <code class="verbatim">z</code> is no longer available outside that scope:</p><div class="sourceCode" id="cb189" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb189-1"><a href="#cb189-1" aria-hidden="true" tabindex="-1"></a>z;;</span></code></pre></div><pre class="example"><code>Line 1, characters 0-1:
1 | z;;;;
    ^
Error: Unbound value z
</code></pre><p>Those can be nested:</p><div class="sourceCode" id="cb191" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb191-1"><a href="#cb191-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">7</span> <span class="kw">in</span></span>
<span id="cb191-2"><a href="#cb191-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> y = x * x <span class="kw">in</span></span>
<span id="cb191-3"><a href="#cb191-3" aria-hidden="true" tabindex="-1"></a>x + y</span>
<span id="cb191-4"><a href="#cb191-4" aria-hidden="true" tabindex="-1"></a>;;</span></code></pre></div><pre class="example"><code>56
</code></pre><h2 id="if-expressions">If expressions</h2><div class="sourceCode" id="cb193" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb193-1"><a href="#cb193-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">max</span> a b =</span>
<span id="cb193-2"><a href="#cb193-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> a &gt; b <span class="kw">then</span> a <span class="kw">else</span> b;;</span></code></pre></div><pre class="example"><code>val max : &#39;a -&gt; &#39;a -&gt; &#39;a = &lt;fun&gt;
</code></pre><div class="sourceCode" id="cb195" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb195-1"><a href="#cb195-1" aria-hidden="true" tabindex="-1"></a><span class="dt">max</span> <span class="dv">9</span> <span class="dv">10</span>;;</span></code></pre></div><pre class="example"><code>10
</code></pre><h2 id="options">Options</h2><p>Used to express that a value might or might not be present.</p><div class="sourceCode" id="cb197" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb197-1"><a href="#cb197-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> divide x y =</span>
<span id="cb197-2"><a href="#cb197-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> y = <span class="dv">0</span> <span class="kw">then</span> <span class="dt">None</span> <span class="kw">else</span> <span class="dt">Some</span> (x / y)</span>
<span id="cb197-3"><a href="#cb197-3" aria-hidden="true" tabindex="-1"></a>;;</span></code></pre></div><pre class="example"><code>val divide : int -&gt; int -&gt; int option = &lt;fun&gt;
</code></pre><p>Values can't be <code class="verbatim">null</code> in <a href="ocaml">OCaml</a>. Missing values are explicit. If you want to allow some data to be absent, you have to use Options.</p><h2 id="pipes">Pipes</h2><p><code class="verbatim">|&gt;</code> pipes work!</p><div class="sourceCode" id="cb199" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb199-1"><a href="#cb199-1" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>] |&gt; <span class="dt">List</span>.map (<span class="kw">fun</span> x -&gt; x * <span class="dv">2</span>)</span></code></pre></div><pre class="example"><code>- : int list = [2; 4; 6]
</code></pre><p>Multiple pipes!</p><div class="sourceCode" id="cb201" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb201-1"><a href="#cb201-1" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>] |&gt; <span class="dt">List</span>.map (<span class="kw">fun</span> x -&gt; x * <span class="dv">2</span>) |&gt; <span class="dt">List</span>.fold_left (+) <span class="dv">0</span></span></code></pre></div><pre class="example"><code>- : int = 12
</code></pre><p><code class="verbatim">@@</code> is like a reverse pipe</p><div class="sourceCode" id="cb203" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb203-1"><a href="#cb203-1" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.map (<span class="kw">fun</span> x -&gt; x * <span class="dv">2</span>) @@ [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>]</span></code></pre></div><pre class="example"><code>- : int list = [2; 4; 6]
</code></pre><h2 id="imperative-programming">Imperative Programming</h2><p><a href="ocaml">OCaml</a> is mostly pure and functional. Almost all data structures are immutable. But <a href="ocaml">OCaml</a> does support imperative programming.</p><h3 id="arrays">Arrays</h3><div class="sourceCode" id="cb205" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb205-1"><a href="#cb205-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> numbers = [| <span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>; <span class="dv">5</span> |];;</span></code></pre></div><pre class="example"><code>val numbers : int array = [|1; 2; 3; 4; 5|]
</code></pre><p><code class="verbatim">.(i)</code> is used to access an element of an array by index <code class="verbatim">i</code>. The <code class="verbatim">&lt;-</code> syntax is used for modification.</p><div class="sourceCode" id="cb207" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb207-1"><a href="#cb207-1" aria-hidden="true" tabindex="-1"></a>numbers.(<span class="dv">2</span>) &lt;- <span class="dv">4</span>;;</span></code></pre></div><pre class="example"><code>- : unit = ()
</code></pre><p>Because the elements of the array are counted starting from zero, <code class="verbatim">.i(2)</code> is the third element.</p><div class="sourceCode" id="cb209" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb209-1"><a href="#cb209-1" aria-hidden="true" tabindex="-1"></a>numbers;;</span></code></pre></div><pre class="example"><code>- : int array = [|1; 2; 4; 4; 5|]
</code></pre><h3 id="refs">Refs</h3><h4 id="basic">Basic</h4><div class="sourceCode" id="cb211" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb211-1"><a href="#cb211-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = { contents = <span class="dv">0</span> };;</span></code></pre></div><pre class="example"><code>val x : int ref = {contents = 0}
</code></pre><div class="sourceCode" id="cb213" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb213-1"><a href="#cb213-1" aria-hidden="true" tabindex="-1"></a>x.contents &lt;- x.contents + <span class="dv">1</span>;;</span></code></pre></div><pre class="example"><code>- : unit = ()
</code></pre><div class="sourceCode" id="cb215" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb215-1"><a href="#cb215-1" aria-hidden="true" tabindex="-1"></a>x;;</span></code></pre></div><pre class="example"><code>- : int ref = {contents = 1}
</code></pre><h4 id="more-terse-syntax">More Terse Syntax</h4><div class="sourceCode" id="cb217" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb217-1"><a href="#cb217-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dt">ref</span> <span class="dv">0</span>;;</span></code></pre></div><pre class="example"><code>val x : int ref = {contents = 0}
</code></pre><div class="sourceCode" id="cb219" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb219-1"><a href="#cb219-1" aria-hidden="true" tabindex="-1"></a>!x;;</span></code></pre></div><pre class="example"><code>- : int = 0
</code></pre><div class="sourceCode" id="cb221" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb221-1"><a href="#cb221-1" aria-hidden="true" tabindex="-1"></a>x := !x + <span class="dv">1</span>;;</span></code></pre></div><pre class="example"><code>- : unit = ()
</code></pre><div class="sourceCode" id="cb223" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb223-1"><a href="#cb223-1" aria-hidden="true" tabindex="-1"></a>!x;;</span></code></pre></div><pre class="example"><code>- : int = 1
</code></pre><h4 id="real-life-example">Real-life Example</h4><div class="sourceCode" id="cb225" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb225-1"><a href="#cb225-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> sum <span class="dt">list</span> =</span>
<span id="cb225-2"><a href="#cb225-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> sum = <span class="dt">ref</span> <span class="dv">0</span> <span class="kw">in</span></span>
<span id="cb225-3"><a href="#cb225-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">List</span>.iter (<span class="kw">fun</span> x -&gt; sum := !sum + x) <span class="dt">list</span>;</span>
<span id="cb225-4"><a href="#cb225-4" aria-hidden="true" tabindex="-1"></a>  !sum</span>
<span id="cb225-5"><a href="#cb225-5" aria-hidden="true" tabindex="-1"></a>;;</span></code></pre></div><pre class="example"><code>val sum : int list -&gt; int = &lt;fun&gt;
</code></pre><div class="sourceCode" id="cb227" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb227-1"><a href="#cb227-1" aria-hidden="true" tabindex="-1"></a>sum [<span class="dv">5</span>; <span class="dv">5</span>; <span class="dv">5</span>];;</span></code></pre></div><pre class="example"><code>- : int = 15
</code></pre><h3 id="for-loops">For loops</h3><div class="sourceCode" id="cb229" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb229-1"><a href="#cb229-1" aria-hidden="true" tabindex="-1"></a><span class="kw">for</span> i = <span class="dv">1</span> <span class="kw">to</span> <span class="dv">5</span> <span class="kw">do</span></span>
<span id="cb229-2"><a href="#cb229-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">print_endline</span> (<span class="dt">string_of_int</span> i)</span>
<span id="cb229-3"><a href="#cb229-3" aria-hidden="true" tabindex="-1"></a><span class="kw">done</span></span></code></pre></div><pre class="example"><code>1
2
3
4
5
- : unit = ()
</code></pre><div class="sourceCode" id="cb231" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb231-1"><a href="#cb231-1" aria-hidden="true" tabindex="-1"></a><span class="kw">for</span> i = <span class="dv">5</span> <span class="kw">downto</span> <span class="dv">1</span> <span class="kw">do</span></span>
<span id="cb231-2"><a href="#cb231-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">print_endline</span> (<span class="dt">string_of_int</span> i)</span>
<span id="cb231-3"><a href="#cb231-3" aria-hidden="true" tabindex="-1"></a><span class="kw">done</span></span></code></pre></div><pre class="example"><code>5
4
3
2
1
- : unit = ()
</code></pre><h3 id="while-loops">While loops</h3><p>Have to use <code class="verbatim">refs</code> in order to be able to quit the loop</p><div class="sourceCode" id="cb233" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb233-1"><a href="#cb233-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> quit_loop = <span class="dt">ref</span> <span class="kw">false</span> <span class="kw">in</span></span>
<span id="cb233-2"><a href="#cb233-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">while</span> <span class="dt">not</span> !quit_loop <span class="kw">do</span></span>
<span id="cb233-3"><a href="#cb233-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">print_endline</span> <span class="st">&quot;this will print once&quot;</span>;</span>
<span id="cb233-4"><a href="#cb233-4" aria-hidden="true" tabindex="-1"></a>    quit_loop := <span class="kw">true</span></span>
<span id="cb233-5"><a href="#cb233-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code></pre></div><pre class="example"><code>this will print once
- : unit = ()
</code></pre><h2 id="modules">Modules</h2><p>Module names always start with an uppercase letter.</p><h3 id="local-imports">Local Imports</h3><div class="sourceCode" id="cb235" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb235-1"><a href="#cb235-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ratio x y =</span>
<span id="cb235-2"><a href="#cb235-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">open</span> Float.O <span class="kw">in</span></span>
<span id="cb235-3"><a href="#cb235-3" aria-hidden="true" tabindex="-1"></a>  of_int x / of_int y</span>
<span id="cb235-4"><a href="#cb235-4" aria-hidden="true" tabindex="-1"></a>;;</span></code></pre></div><pre class="example"><code>val ratio : int -&gt; int -&gt; Base.Float.t = &lt;fun&gt;
</code></pre><p>More concise syntax:</p><div class="sourceCode" id="cb237" data-results="verbatim" data-exports="both"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb237-1"><a href="#cb237-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ratio x y =</span>
<span id="cb237-2"><a href="#cb237-2" aria-hidden="true" tabindex="-1"></a>  Float.O.(of_int x / of_int y)</span>
<span id="cb237-3"><a href="#cb237-3" aria-hidden="true" tabindex="-1"></a>;;</span></code></pre></div><pre class="example"><code>val ratio : int -&gt; int -&gt; Base.Float.t = &lt;fun&gt;
</code></pre><h2 id="file-manipulation">File manipulation</h2><p><a href="https://ocaml.org/learn/tutorials/file_manipulation.html">https://ocaml.org/learn/tutorials/file_manipulation.html</a></p><h2 id="packages">Packages</h2><h3 id="base">Base</h3><p><a href="https://ocaml.janestreet.com/ocaml-core/v0.12/doc/base/index.html">https://ocaml.janestreet.com/ocaml-core/v0.12/doc/base/index.html</a></p><blockquote><p>An addition to the standard library developed by Jane Street.</p></blockquote><h3 id="ocaml-for-the-web">OCaml for the Web</h3><p><a href="https://esy.sh/en/">https://esy.sh/en/</a></p><h3 id="dream">Dream</h3><p><a href="https://aantron.github.io/dream/">https://aantron.github.io/dream/</a></p><blockquote><p>Tidy, feature-complete Web framework</p></blockquote><h4 id="dream-cli">Dream CLI</h4><p><a href="https://github.com/tmattio/dream-cli">https://github.com/tmattio/dream-cli</a></p><h3 id="yocaml">YOCaml</h3><p><a href="https://github.com/xhtmlboi/yocaml">https://github.com/xhtmlboi/yocaml</a></p><blockquote><p>YOCaml is a static site generator, mostly written in OCaml</p></blockquote><h3 id="bonsai">Bonsai</h3><p><a href="https://github.com/janestreet/bonsai">https://github.com/janestreet/bonsai</a></p><blockquote><p>Bonsai is a library for building interactive browser-based UI.</p></blockquote><h3 id="caqti">Caqti</h3><p><a href="https://github.com/paurkedal/ocaml-caqti">https://github.com/paurkedal/ocaml-caqti</a></p><blockquote><p>Cooperative-threaded access to relational data</p></blockquote><blockquote><p>kind of like Python's SQLAlchemy or Java's JDBC</p></blockquote><h4 id="resources">Resources</h4><p><a href="https://medium.com/@bobbypriambodo/interfacing-ocaml-and-postgresql-with-caqti-a92515bdaa11">https://medium.com/@bobbypriambodo/interfacing-ocaml-and-postgresql-with-caqti-a92515bdaa11</a></p><p><a href="https://ceramichacker.com/blog/28-2x-backend-webdev-w-dream-and-caqti">https://ceramichacker.com/blog/28-2x-backend-webdev-w-dream-and-caqti</a></p><h3 id="opium">Opium</h3><p><a href="https://github.com/rgrinberg/opium">https://github.com/rgrinberg/opium</a></p><blockquote><p>Sinatra like web toolkit for OCaml</p></blockquote><h2 id="tools">Tools</h2><h3 id="spin">Spin</h3><p><a href="https://github.com/tmattio/spin">https://github.com/tmattio/spin</a></p><blockquote><p>OCaml project generator.</p></blockquote><h2 id="resources-1">Resources</h2><h3 id="ocaml-docs">OCaml docs</h3><p><a href="https://ocaml.org/learn/">https://ocaml.org/learn/</a></p><h3 id="the-ocaml-api">The OCaml API</h3><p><a href="https://v2.ocaml.org/api/index.html">https://v2.ocaml.org/api/index.html</a></p><h3 id="the-ocaml-system">The OCaml system</h3><p><a href="https://v2.ocaml.org/releases/4.14/htmlman/index.html">https://v2.ocaml.org/releases/4.14/htmlman/index.html</a></p><h3 id="cornell-cs3110">Cornell CS3110</h3><ul><li><a href="https://www.cs.cornell.edu/courses/cs3110/2019sp/textbook/">https://www.cs.cornell.edu/courses/cs3110/2019sp/textbook/</a></li><li><a href="https://cs3110.github.io/textbook/cover.html">https://cs3110.github.io/textbook/cover.html</a></li><li><a href="https://youtube.com/playlist?list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU">https://youtube.com/playlist?list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU</a></li></ul><h3 id="real-world-ocaml">Real World OCaml</h3><p><a href="https://dev.realworldocaml.org/">https://dev.realworldocaml.org/</a></p><p>Heavily uses Jane Street packages</p><h3 id="ocaml-from-the-very-beginning">OCaml from the Very Beginning</h3><p><a href="https://johnwhitington.net/ocamlfromtheverybeginning/index.html">https://johnwhitington.net/ocamlfromtheverybeginning/index.html</a></p><h3 id="what-i-wish-i-knew-when-learning-ocaml">What I wish I knew when learning OCaml</h3><p><a href="https://baturin.org/docs/ocaml-faq/">https://baturin.org/docs/ocaml-faq/</a></p><h3 id="ocaml-5-tutorial">OCaml 5 tutorial</h3><p><a href="https://github.com/kayceesrk/ocaml5-tutorial/">https://github.com/kayceesrk/ocaml5-tutorial/</a></p></div></body></html>