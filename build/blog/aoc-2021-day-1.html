<!doctype html><html lang="en"><head><title>‚ú® Advent of Code: Day 1 in Julia - Damien Gonot</title><link rel="stylesheet" href="/main.css"><link rel="stylesheet" href="/katex.min.css"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="Introduction

Inspired by the many articles about learning in public, I decided to
write a blog post about my learnings for the first day of Advent of Code
2021.

Every year, I‚Äôm looking forward to participate in Advent of Code. Those
daily puzzles are super delightful and it‚Äôs so rewarding to ge..."><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></head><body class="bg-white dark:bg-black"><header class="bg-indigo-600 dark:bg-black text-center text-white p-8"><div class="text-4xl font-bold mb-4">Damien Gonot</div><div class="text-xl flex flex-wrap gap-x-4 gap-y-2 justify-center"><a href="/" class="hover:underline">Home</a> <a href="/blog" class="hover:underline">Blog</a> <a href="/notes" class="hover:underline">Notes</a> <a href="/about" class="hover:underline">About</a> <button id="theme" class="text-2xl hover:cursor-pointer hover:dark" onclick="toggleTheme()">üåù</button></div><script src="/custom.js"></script><script src="/highlight.js"></script><script defer="defer" src="/katex.min.js"></script><script defer="defer" src="/katex-auto-render.min.js"></script></header><div class="prose prose-indigo dark:prose-invert dark:prose-a:text-indigo-400 max-w-3xl mx-auto p-8"><h1 class="text-center">‚ú® Advent of Code: Day 1 in Julia</h1><div class="text-center">written on 2021-12-01</div><h2 id="introduction">Introduction</h2><p>Inspired by the <a href="https://www.swyx.io/learn-in-public/">many</a> <a href="https://medium.com/my-learning-journal/why-you-should-learn-in-public-4fd3a6239549">articles</a> about learning in public, I decided to write a blog post about my learnings for the first day of Advent of Code 2021.</p><p>Every year, I‚Äôm looking forward to participate in <a href="https://adventofcode.com/">Advent of Code</a>. Those daily puzzles are super delightful and it‚Äôs so rewarding to get a working solution. Though with the rising difficulty it‚Äôs very hard to nail every challenge all the way to the end but hey at least I‚Äôve worked on Day 1!</p><p>This year, like <a href="https://github.com/mewfree/advent-of-meow-2020">last year</a>, I decided to use <a href="https://julialang.org/">Julia</a>. I like to describe it as ‚ÄúAs simple as Python, as fast as C‚Äù, but there are also some features that I really like (a fast and awesome REPL, pipes (<code>|&gt;</code>), vectorized functions‚Ä¶).</p><h2 id="parsing-input">Parsing Input</h2><p>Parsing input is the first step in solving an Advent of Code puzzle.</p><p>My biggest tip about Advent of Code is to test your code against the public (I personally save it in a file <code>test_input</code> next to my real, private <code>input</code> file).</p><h3 id="initial-method">Initial Method</h3><p>By solving <a href="https://github.com/mewfree/advent-of-meow-2020">last year‚Äôs Advent of Code</a> in Julia too, I remembered <a href="https://github.com/mewfree/advent-of-meow-2020/blob/main/day-01/solution.jl#L1">the method I was using</a>, which is essentially: - read file as a string - split by newline - for each line parse string as an Integer</p><div class="sourceCode" id="cb1"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>input <span class="op">=</span> <span class="cn">open</span>(f<span class="op">-&gt;</span><span class="cn">read</span>(f<span class="op">,</span> <span class="dt">String</span>)<span class="op">,</span> <span class="st">&quot;test_input&quot;</span>) <span class="op">|&gt;</span> f<span class="op">-&gt;</span>split(f<span class="op">,</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>) <span class="op">|&gt;</span> a<span class="op">-&gt;</span>map(s<span class="op">-&gt;</span>parse(<span class="dt">Int</span><span class="op">,</span> s)<span class="op">,</span> a)</span></code></pre></div><p>But I was not satisfied with it and kept feeling like there must be a better way‚Ä¶</p><h3 id="cleaner-method">Cleaner Method</h3><p>After some research that‚Äôs how I found out about <a href="https://docs.julialang.org/en/v1/stdlib/DelimitedFiles/">Delimited Files</a>, part of Julia‚Äôs standard library! More specifically, the <code>readdlm</code> method that allows to read a file as a matrix while also handling parsing to integers or floats at the same time.</p><div class="sourceCode" id="cb2"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> <span class="kw">using</span> DelimitedFiles</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> input <span class="op">=</span> readdlm(<span class="st">&quot;test_input&quot;</span><span class="op">,</span> <span class="dt">Int</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="fl">10</span>√ó<span class="fl">1</span> <span class="dt">Matrix</span>{<span class="dt">Int64</span>}<span class="op">:</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a> <span class="fl">199</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a> <span class="fl">200</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a> <span class="fl">208</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a> <span class="fl">210</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a> <span class="fl">200</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a> <span class="fl">207</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a> <span class="fl">240</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a> <span class="fl">269</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a> <span class="fl">260</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a> <span class="fl">263</span></span></code></pre></div><p>What we want is a vector though (what in most other languages would be called an array or list, essentially a 1-Dimension Matrix in Julia‚Äôs perspective), but the <code>vec</code> function easily handles that for us:</p><div class="sourceCode" id="cb3"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> input <span class="op">=</span> readdlm(<span class="st">&quot;test_input&quot;</span><span class="op">,</span> <span class="dt">Int</span>) <span class="op">|&gt;</span> vec</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="fl">10</span><span class="op">-</span>element <span class="dt">Vector</span>{<span class="dt">Int64</span>}<span class="op">:</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a> <span class="fl">199</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a> <span class="fl">200</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a> <span class="fl">208</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a> <span class="fl">210</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a> <span class="fl">200</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a> <span class="fl">207</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a> <span class="fl">240</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a> <span class="fl">269</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a> <span class="fl">260</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a> <span class="fl">263</span></span></code></pre></div><h2 id="part-1-solution">Part 1 Solution</h2><h3 id="map---reduce">Map -&gt; Reduce</h3><p>Alright, now to the good stuff. I won‚Äôt go over <a href="https://adventofcode.com/2021/day/1">Day 1‚Äôs puzzle</a> here, I would recommed you go through it yourself first! We want to know whether element <code>n</code> is lesser than element <code>n+1</code>, or actually whether element <code>n</code> is greater than element <code>n-1</code>. My first guess is to <code>map</code> over the input, using <code>enumerate</code> to get the index of the <code>n</code>th element, and using that to compare it to the <code>n-1</code>th element. A quick <a href="https://docs.julialang.org/en/v1/manual/control-flow/#man-conditional-evaluation">ternary operator</a> is necessary to handle the case of the first element.</p><div class="sourceCode" id="cb4"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> map(x <span class="op">-&gt;</span> x[<span class="fl">1</span>] <span class="op">-</span> <span class="fl">1</span> <span class="op">==</span> <span class="fl">0</span> ? <span class="ex">false</span> <span class="op">:</span> x[<span class="fl">2</span>] <span class="op">&gt;</span> input[x[<span class="fl">1</span>] <span class="op">-</span> <span class="fl">1</span>]<span class="op">,</span> enumerate(input))</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="fl">10</span><span class="op">-</span>element <span class="dt">Vector</span>{<span class="dt">Bool</span>}<span class="op">:</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a> <span class="fl">0</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a> <span class="fl">1</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a> <span class="fl">1</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a> <span class="fl">1</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a> <span class="fl">0</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a> <span class="fl">1</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a> <span class="fl">1</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a> <span class="fl">1</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a> <span class="fl">0</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a> <span class="fl">1</span></span></code></pre></div><p>Now that we have a list of booleans (or ones and zeros), a quick reduce allows us to sum up the values:</p><div class="sourceCode" id="cb5"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> reduce(<span class="op">+,</span> map(x <span class="op">-&gt;</span> x[<span class="fl">1</span>] <span class="op">-</span> <span class="fl">1</span> <span class="op">==</span> <span class="fl">0</span> ? <span class="ex">false</span> <span class="op">:</span> x[<span class="fl">2</span>] <span class="op">&gt;</span> input[x[<span class="fl">1</span>] <span class="op">-</span> <span class="fl">1</span>]<span class="op">,</span> enumerate(input)))</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="fl">7</span></span></code></pre></div><h3 id="zip---map---sum">Zip -&gt; Map -&gt; Sum</h3><p>By sharing my first solution with my colleagues and reviewing others, I quickly got two feedback: - <code>reduce</code> is not necessary and a simple <code>sum</code> should work - <code>zip</code> can be very useful! (I always forget about <code>zip</code>‚Ä¶)</p><div class="sourceCode" id="cb6"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> map(((x<span class="op">,</span> y)<span class="op">,</span>) <span class="op">-&gt;</span> x <span class="op">&lt;</span> y<span class="op">,</span> zip(input<span class="op">,</span> input[<span class="fl">2</span><span class="op">:</span><span class="kw">end</span>]))</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="fl">9</span><span class="op">-</span>element <span class="dt">Vector</span>{<span class="dt">Bool</span>}<span class="op">:</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a> <span class="fl">1</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a> <span class="fl">1</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a> <span class="fl">1</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a> <span class="fl">0</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a> <span class="fl">1</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a> <span class="fl">1</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a> <span class="fl">1</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a> <span class="fl">0</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a> <span class="fl">1</span></span></code></pre></div><p>Some explanation of the code above. This is what zip does:</p><div class="sourceCode" id="cb7"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> zip(input<span class="op">,</span> input[<span class="fl">2</span><span class="op">:</span><span class="kw">end</span>]) <span class="op">|&gt;</span> collect</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="fl">9</span><span class="op">-</span>element <span class="dt">Vector</span>{<span class="dt">Tuple</span>{<span class="dt">Int64</span><span class="op">,</span> <span class="dt">Int64</span>}}<span class="op">:</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a> (<span class="fl">199</span><span class="op">,</span> <span class="fl">200</span>)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a> (<span class="fl">200</span><span class="op">,</span> <span class="fl">208</span>)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a> (<span class="fl">208</span><span class="op">,</span> <span class="fl">210</span>)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a> (<span class="fl">210</span><span class="op">,</span> <span class="fl">200</span>)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a> (<span class="fl">200</span><span class="op">,</span> <span class="fl">207</span>)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a> (<span class="fl">207</span><span class="op">,</span> <span class="fl">240</span>)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a> (<span class="fl">240</span><span class="op">,</span> <span class="fl">269</span>)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a> (<span class="fl">269</span><span class="op">,</span> <span class="fl">260</span>)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a> (<span class="fl">260</span><span class="op">,</span> <span class="fl">263</span>)</span></code></pre></div><p>Remember that Julia‚Äôs indexes start at 1, not 0 (similiar to other mathematics-oriented languages like R or MATLAB), meaning that we combine the initial vector with the same vector starting from the 2nd element. The result is a vector of tuples.</p><p>The <code>((x, y),) -&gt; x &lt; y</code> notation allows to destructurate the tuple inside the list of parameters, instead of having to do something like <code>x -&gt; x[1] &lt; x[2]</code> (which you might consider cleaner, but I don‚Äôt, even though it‚Äôs technically terser).</p><p>Piping a <code>sum</code> at the end:</p><div class="sourceCode" id="cb8"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> map(((x<span class="op">,</span> y)<span class="op">,</span>) <span class="op">-&gt;</span> x <span class="op">&lt;</span> y<span class="op">,</span> zip(input<span class="op">,</span> input[<span class="fl">2</span><span class="op">:</span><span class="kw">end</span>])) <span class="op">|&gt;</span> sum</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="fl">7</span></span></code></pre></div><h3 id="diff">Diff</h3><p>I was pretty satisfied with this solution, but as I looked around the amazing <a href="https://www.reddit.com/r/adventofcode/">/r/adventofcode</a>‚Äôs <a href="https://www.reddit.com/r/adventofcode/comments/r66vow/2021_day_1_solutions/">solution megathread</a>, I saw someone using a simply <code>diff</code> function in R.</p><p>And to my pleasant surprise, Julia has <a href="https://docs.julialang.org/en/v1/base/arrays/#Base.diff">a <code>diff</code> function</a> too!</p><div class="sourceCode" id="cb9"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> diff(input)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="fl">9</span><span class="op">-</span>element <span class="dt">Vector</span>{<span class="dt">Int64</span>}<span class="op">:</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>   <span class="fl">1</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>   <span class="fl">8</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>   <span class="fl">2</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a> <span class="op">-</span><span class="fl">10</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>   <span class="fl">7</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  <span class="fl">33</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>  <span class="fl">29</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">-</span><span class="fl">9</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>   <span class="fl">3</span></span></code></pre></div><p>It automatically calculates the difference between ‚Äúnext‚Äù elements of arrays/vectors.</p><p><code>Map</code>ing over this result to check if the result is positive:</p><div class="sourceCode" id="cb10"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> map(x <span class="op">-&gt;</span> x <span class="op">&gt;</span> <span class="fl">0</span><span class="op">,</span> diff(input))</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="fl">9</span><span class="op">-</span>element <span class="dt">Vector</span>{<span class="dt">Bool</span>}<span class="op">:</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a> <span class="fl">1</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a> <span class="fl">1</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a> <span class="fl">1</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a> <span class="fl">0</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a> <span class="fl">1</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a> <span class="fl">1</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a> <span class="fl">1</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a> <span class="fl">0</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a> <span class="fl">1</span></span></code></pre></div><p>And once again, piping a <code>sum</code> at the end:</p><div class="sourceCode" id="cb11"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> map(x <span class="op">-&gt;</span> x <span class="op">&gt;</span> <span class="fl">0</span><span class="op">,</span> diff(input)) <span class="op">|&gt;</span> sum</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="fl">7</span></span></code></pre></div><h3 id="final-solution">Final Solution</h3><p>To recap, this gives us a one-liner:</p><div class="sourceCode" id="cb12"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> readdlm(<span class="st">&quot;test_input&quot;</span><span class="op">,</span> <span class="dt">Int</span>) <span class="op">|&gt;</span> vec <span class="op">|&gt;</span> v<span class="op">-&gt;</span>map(x <span class="op">-&gt;</span> x <span class="op">&gt;</span> <span class="fl">0</span><span class="op">,</span> diff(v)) <span class="op">|&gt;</span> sum</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="fl">7</span></span></code></pre></div><h2 id="part-2-solution">Part 2 Solution</h2><p>Not much evolution here, but we‚Äôre going to benefit from everything we learnt in part 1.</p><p>We need to create sliding windows of size 3. I didn‚Äôt feel like implement it myself as I don‚Äôt enjoy reinventing the wheel, so looked around for an available method.</p><p>The <a href="https://juliafolds.github.io/Transducers.jl/dev/reference/manual/#Transducers.Partition"><code>Partition</code></a> method from <a href="https://github.com/JuliaFolds/Transducers.jl">Transducers.jl</a> looked like it would work.</p><div class="sourceCode" id="cb13"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> <span class="kw">using</span> Transducers</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> windows <span class="op">=</span> input <span class="op">|&gt;</span> Transducers.Partition(<span class="fl">3</span><span class="op">;</span> step <span class="op">=</span> <span class="fl">1</span>) <span class="op">|&gt;</span> Map(copy) <span class="op">|&gt;</span> collect</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="fl">8</span><span class="op">-</span>element <span class="dt">Vector</span>{<span class="dt">Vector</span>{<span class="dt">Int64</span>}}<span class="op">:</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a> [<span class="fl">199</span><span class="op">,</span> <span class="fl">200</span><span class="op">,</span> <span class="fl">208</span>]</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a> [<span class="fl">200</span><span class="op">,</span> <span class="fl">208</span><span class="op">,</span> <span class="fl">210</span>]</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a> [<span class="fl">208</span><span class="op">,</span> <span class="fl">210</span><span class="op">,</span> <span class="fl">200</span>]</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a> [<span class="fl">210</span><span class="op">,</span> <span class="fl">200</span><span class="op">,</span> <span class="fl">207</span>]</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a> [<span class="fl">200</span><span class="op">,</span> <span class="fl">207</span><span class="op">,</span> <span class="fl">240</span>]</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a> [<span class="fl">207</span><span class="op">,</span> <span class="fl">240</span><span class="op">,</span> <span class="fl">269</span>]</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a> [<span class="fl">240</span><span class="op">,</span> <span class="fl">269</span><span class="op">,</span> <span class="fl">260</span>]</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a> [<span class="fl">269</span><span class="op">,</span> <span class="fl">260</span><span class="op">,</span> <span class="fl">263</span>]</span></code></pre></div><p>Nice</p><p>Using the <a href="https://docs.julialang.org/en/v1/manual/functions/#man-vectorized">dot syntax to vectorize function</a>, we can get the sum of each window:</p><div class="sourceCode" id="cb14"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> sum.(windows)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="fl">8</span><span class="op">-</span>element <span class="dt">Vector</span>{<span class="dt">Int64</span>}<span class="op">:</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a> <span class="fl">607</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a> <span class="fl">618</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a> <span class="fl">618</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a> <span class="fl">617</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a> <span class="fl">647</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a> <span class="fl">716</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a> <span class="fl">769</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a> <span class="fl">792</span></span></code></pre></div><p>And we can still use the same workflow as part 1 to calculate differences and how many times there was an increase in value.</p><p>Or if you really want a one-liner‚Ä¶</p><div class="sourceCode" id="cb15"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> readdlm(<span class="st">&quot;test_input&quot;</span><span class="op">,</span> <span class="dt">Int</span>) <span class="op">|&gt;</span> vec <span class="op">|&gt;</span> Transducers.Partition(<span class="fl">3</span><span class="op">;</span> step <span class="op">=</span> <span class="fl">1</span>) <span class="op">|&gt;</span> Map(copy) <span class="op">|&gt;</span> collect <span class="op">|&gt;</span> w<span class="op">-&gt;</span>map(x <span class="op">-&gt;</span> sum(x)<span class="op">,</span> w) <span class="op">|&gt;</span> v<span class="op">-&gt;</span>map(x <span class="op">-&gt;</span> x <span class="op">&gt;</span> <span class="fl">0</span><span class="op">,</span> diff(v)) <span class="op">|&gt;</span> sum</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="fl">5</span></span></code></pre></div><h2 id="conclusion">Conclusion</h2><p>Here‚Äôs the full script that is <a href="https://github.com/mewfree/advent-of-meow-2021/blob/main/day-01/solution.jl">available on GitHub</a>:</p><div class="sourceCode" id="cb16"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> DelimitedFiles</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> Transducers</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>input <span class="op">=</span> readdlm(<span class="st">&quot;input&quot;</span><span class="op">,</span> <span class="dt">Int</span>) <span class="op">|&gt;</span> vec</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>compare(vec) <span class="op">=</span> map(x <span class="op">-&gt;</span> x <span class="op">&gt;</span> <span class="fl">0</span><span class="op">,</span> diff(vec))</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>windows <span class="op">=</span> input <span class="op">|&gt;</span> Transducers.Partition(<span class="fl">3</span><span class="op">;</span> step <span class="op">=</span> <span class="fl">1</span>) <span class="op">|&gt;</span> Map(copy) <span class="op">|&gt;</span> collect</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>println(<span class="st">&quot;Part 1: &quot;</span><span class="op">,</span> input <span class="op">|&gt;</span> compare <span class="op">|&gt;</span> sum)</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>println(<span class="st">&quot;Part 2: &quot;</span><span class="op">,</span> sum.(windows) <span class="op">|&gt;</span> compare <span class="op">|&gt;</span> sum)</span></code></pre></div><p>Pretty satisfied with this! I don‚Äôt think there‚Äôs much left to improve.</p><p>Main learnings for me: - <code>readdlm</code> is super useful - <code>zip</code> can be cleaner than fiddling with <code>enumerate</code> and indexes - vectorized functions rock!</p><p>I don‚Äôt think it will be sustainable for me to keep blogging about next Advent of Code puzzles, but hope this was an interesting read and that you learnt something.</p></div></body></html>